<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8">
  <title>Python Technical Documentation Page</title>
  <link rel="stylesheet" href="./style.css">

</head>
<body>
<!-- partial:index.partial.html -->
<code>
  <nav id="navbar">
    <header class="navbar-title">
      Python contents
    </header>
  <ul>
    <li>
      <a class="nav-link" href="#Introduction">Introduction</a>
    </li>
    <li>
      <a class="nav-link" href="#Guido_Van_Rossum">Guido Van Rossum</a>
    </li>
    <li>
      <a class="nav-link" href="#History">History</a>
    </li>
    <li>
      <a class="nav-link" href="#Features_and_Philosophy">Features and Philosophy</a>
    </li>
    <li>
      <a class="nav-link" href="#Syntax_and_Semantics">Syntax and Semantics</a>
    </li>
    <li>
      <a class="nav-link" href="#Libraries">Libraries</a>
    </li>
    <li>
      <a class="nav-link" href="#Development">Development</a>
    </li>
    <li>
      <a class="nav-link" href="#Implementations">Implementations</a>
    </li>
    <li>
      <a class="nav-link" href="#Uses">Uses</a>
    </li>
    <li>
      <a class="nav-link" href="#Influence">Influence</a>
    </li>
  </ul>
</nav>
		<main id="main-doc">
			<section class="main-section" id="Introduction">
				<header>
					<h2>Introduction</h2>
				</header>
				<article>
					<p>
						Python the language created by Guido Van Rossum and first released in 1991 is an interpreted,
						high-level, general-purpose programming language.
						It was conceived in the lates 80's as a sucessor of the ABC language, and is design philosophy
						emphasizes code readability with its notable use of significant whitespace
						Its language constructs and object-oriented approach aim to help programmers write clear, logical code
						for small and large-scale projects.
						Python supports procedural, object-oriented, and functional programming. It is dinamically typed and
						garbage collected.
						The most common adjective given to Python is that a "batteries included" kind of language du to its
						comprehensive standard library.
						It is maintained and developed by the Python Software Fundation, an nonprofit organization based in
						Delaware, United States.
					</p>
				</article>
				<section class="main-section" id="Guido_Van_Rossum">
					<header>
						<h2>Guido Van Rossum</h2>
					</header>
					<p>
						Born in Haarlem on the Netherlands on 31 of January, 1956, Guido Van Rossum is the "father" of the
						Python language and as he describe himself the "Benevolent dictator for life" of it.
						With a master's degree in mathematics and computer science from the University of Amsterdam(achieved
						in
						1982). his first notable work was is participation on the development of the ABC language,
						while working at the Centrum Wiskond & Informatica, an national research institute based in Amsterdam.
						By December of 1989, Guido was looking for a "hobby" to keep him busy during the Christmas week, so he
						decided to write an interpreter for a new scripting
						language he had been thinking lately, descending from the ABC language and also appealing to Unix/C
						hackers. He refers that the name for the programming language was inspired by the movie "Monty Pyhon's
						Flying Circus".
					</p>
					<p>
						He has worked for various research institutes, in Netherlands the previous mentioned Centrum Wiskond &
						Informatica(CWI), in the US on the National Instute of Standards and Technology(NIST), and the
						Corporation for National Research Initiatives(CNRI).

					</p>
					</article>
				</section>
				<section class="main-section" id="History">
					<header>
						<h2>History</h2>
					</header>
					<p>In February 1991, Van Rossum published the code (labeled version 0.9.0) to alt.sources.Already present
						at this stage in development were classes with inheritance, exception handling, functions, and the
						core
						datatypes of list, dict, str and so on. Also in this initial release was a module system borrowed from
						Modula-3; Van Rossum describes the module as "one of Python's major programming units". Python's
						exception model also resembles Modula-3's, with the addition of an else clause. In 1994
						comp.lang.python, the primary discussion forum for Python, was formed, marking a milestone in the
						growth of Python's userbase.
					</p>
					<br>
					<h3><u><em>Version 1</em></u></h3>

					<p>
						Python reached version 1.0 in January 1994. The major new features included in this release were the
						functional programming tools lambda, map, filter and reduce. Van Rossum stated that "Python acquired
						lambda, reduce(), filter() and map(), courtesy of a Lisp hacker who missed them and submitted working
						patches".
						The last version released while Van Rossum was at CWI was Python 1.2. In 1995, Van Rossum continued
						his
						work on Python at the Corporation for National Research Initiatives (CNRI) in Reston, Virginia from
						where he released several versions.
						By version 1.4, Python had acquired several new features. Notable among these are the Modula-3
						inspired
						keyword arguments (which are also similar to Common Lisp's keyword arguments) and built-in support for
						complex numbers. Also included is a basic form of data hiding by name mangling, though this is easily
						bypassed.
						During Van Rossum's stay at CNRI, he launched the Computer Programming for Everybody (CP4E)
						initiative,
						intending to make programming more accessible to more people, with a basic "literacy" in programming
						languages, similar to the basic English literacy and mathematics skills required by most employers.
						Python served a central role in this: because of its focus on clean syntax, it was already suitable,
						and CP4E's goals bore similarities to its predecessor, ABC. The project was funded by <em>DARPA</em>.
						As of 2007, the CP4E project is inactive, and while Python attempts to be easily learnable and not too
						arcane in its syntax and semantics, reaching out to non-programmers is not an active concern.
					</p>

					<br>

					<h3><u><em>BeOpen</em></u></h3>

					<p>
						In 2000, the Python core development team moved to BeOpen.com to form the BeOpen PythonLabs team. CNRI
						requested that a version 1.6 be released, summarizing Python's development up to the point at which
						the
						development team left CNRI. Consequently, the release schedules for 1.6 and 2.0 had a significant
						amount of overlap. Python 2.0 was the only release from BeOpen.com. After Python 2.0 was released by
						BeOpen.com, Guido van Rossum and the other PythonLabs developers joined Digital Creations.
						The Python 1.6 release included a new CNRI license that was substantially longer than the CWI license
						that had been used for earlier releases. The new license included a clause stating that the license
						was
						governed by the laws of the State of Virginia. The Free Software Foundation argued that the
						choice-of-law clause was incompatible with the GNU General Public License. BeOpen, CNRI and the FSF
						negotiated a change to Python's free software license that would make it GPL-compatible. Python 1.6.1
						is essentially the same as Python 1.6, with a few minor bug fixes, and with the new GPL-compatible
						license.
					</p>

					<br>

					<h3><u><em>Version 2</em></u></h3>
					<p>
						Python 2.0, released October 2000, introduced list comprehensions, a feature borrowed from the
						functional programming languages SETL and Haskell. Python's syntax for this construct is very similar
						to Haskell's, apart from Haskell's preference for punctuation characters and Python's preference for
						alphabetic keywords. Python 2.0 also introduced a garbage collection system capable of collecting
						reference cycles.
						Python 2.1 was close to Python 1.6.1, as well as Python 2.0. Its license was renamed Python Software
						Foundation License. All code, documentation and specifications added, from the time of Python 2.1's
						alpha release on, is owned by the Python Software Foundation (PSF), a non-profit organization formed
						in
						2001, modeled after the Apache Software Foundation. The release included a change to the language
						specification to support nested scopes, like other statically scoped languages. (The feature was
						turned
						off by default, and not required, until Python 2.2.)
						Python 2.2 was released on December 2001; a major innovation was the unification of Python's types
						(types written in C) and classes (types written in Python) into one hierarchy. This single unification
						made Python's object model purely and consistently object oriented. Also added were generators which
						were inspired by Icon.
						Python 2.5 was released on September 2006 and introduced the with statement, which encloses a code
						block within a context manager (for example, acquiring a lock before the block of code is run and
						releasing the lock afterwards, or opening a file and then closing it), allowing Resource Acquisition
						Is
						Initialization (RAII)-like behavior and replacing a common try/finally idiom.
						Python 2.6 was released to coincide with Python 3.0, and included some features from that release, as
						well as a "warnings" mode that highlighted the use of features that were removed in Python 3.0.
						Similarly, Python 2.7 coincided with and included features from Python 3.1, which was released on June
						26, 2009. Parallel 2.x and 3.x releases then ceased, and Python 2.7 was the last release in the 2.x
						series. In November 2014, it was announced that Python 2.7 would be supported until 2020, but users
						were encouraged to move to Python 3 as soon as possible.</p>

					<br>

					<h3><u><em>Version 3</em></u></h3>

					<p>
						Python 3.0 (also called "Python 3000" or "Py3K") was released on December 3, 2008. It was designed to
						rectify fundamental design flaws in the language—the changes required could not be implemented while
						retaining full backwards compatibility with the 2.x series, which necessitated a new major version
						number. The guiding principle of Python 3 was: "reduce feature duplication by removing old ways of
						doing things".
						Python 3.0 was developed with the same philosophy as in prior versions. However, as Python had
						accumulated new and redundant ways to program the same task, Python 3.0 had an emphasis on removing
						duplicative constructs and modules, in keeping with "There should be one— and preferably only one
						—obvious way to do it".
						Nonetheless, Python 3.0 remained a multi-paradigm language. Coders could still follow object-oriented,
						structured, and functional programming paradigms, among others, but within such broad choices, the
						details were intended to be more obvious in Python 3.0 than they were in Python 2.x. </p>

					<br>

					<h3><u><em>Compability</em></u></h3>

					<p>Python 3.0 broke backward compatibility, and much Python 2 code does not run unmodified on Python 3.
						Python's dynamic typing combined with the plans to change the semantics of certain methods of
						dictionaries, for example, made perfect mechanical translation from Python 2.x to Python 3.0 very
						difficult. A tool called "2to3" does the parts of translation that can be done automatically. At this,
						2to3 appeared to be fairly successful, though an early review noted that there were aspects of
						translation that such a tool would never be able to handle. Prior to the roll-out of Python 3,
						projects
						requiring compatibility with both the 2.x and 3.x series were recommended to have one source (for the
						2.x series), and produce releases for the Python 3.x platform using 2to3. Edits to the Python 3.x code
						were discouraged for so long as the code needed to run on Python 2.x. This is no longer recommended;
						as
						of 2012 the preferred approach is to create a single code base that can run under both Python 2 and 3
						using compatibility modules.</p>
					<h4><strong>Features</strong></h4>

					<p>Some of the major changes included for Python 3.0 were:
						<ul>
							<li>Changing print so that it is a built-in function, not a statement. This made it easier to
								change a module to use a different print function, as well as making the syntax more regular.
								In Python 2.6 and 2.7 print() is available as a builtin but is masked by the print statement
								syntax, which can be disabled by entering from __future__ import print_function at the top of
								the file</li>
							<li>Removal of the Python 2 input function, and the renaming of the raw_input function to input.
								Python 3's input function behaves like Python 2's raw_input function, in that the input is
								always returned as a string rather than being evaluated as an expression.</li>
							<li>Moving reduce (but not map or filter) out of the built-in namespace and into functools (the
								rationale being code that uses reduce is less readable than code that uses a for loop and
								accumulator variable).</li>
							<li>Adding support for optional function annotations that can be used for informal type
								declarations or other purposes.</li>
							<li>Unifying the str/unicode types, representing text, and introducing a separate immutable bytes
								type; and a mostly corresponding mutable bytearray type, both of which represent arrays of
								bytes.</li>
							<li>Removing backward-compatibility features, including old-style classes, string exceptions, and
								implicit relative imports.</li>
							<li>A change in integer division functionality: in Python 2, 5 / 2 is 2; in Python 3, 5 / 2 is
								2.5.
								(In both Python 2 (2.2 onwards) and Python 3, 5 // 2 is 2).</li>
						</ul>

						<p>Subsequent releases in the Python 3.x series have included additional, substantial new features;
							all
							ongoing development of the language is done in the 3.x series. </p>
					</p>

				</section>
				<section class="main-section" id="Features_and_Philosophy">
					<header>
						<h2>Features and Philosophy</h2>
					</header>
					<p>Python is a multi-paradigm programming language. Object-oriented programming and structured programming
						are fully supported, and many of its features support functional programming and aspect-oriented
						programming (including by metaprogramming and metaobjects (magic methods)). Many other paradigms are
						supported via extensions, including design by contract and logic programming.</p>
					<p>Python uses dynamic typing and a combination of reference counting and a cycle-detecting garbage
						collector for memory management. It also features dynamic name resolution (late binding), which binds
						method and variable names during program execution.</p>
					<p>Python's design offers some support for functional programming in the Lisp tradition. It has filter,
						map, and reduce functions; list comprehensions, dictionaries, sets, and generator expressions. The
						standard library has two modules (itertools and functools) that implement functional tools borrowed
						from Haskell and Standard ML.</p>
					<p>The language's core philosophy is summarized in the document The Zen of Python (PEP 20), which includes
						aphorisms such as:</p>
					<ul>
						<li>Beautiful is better than ugly.</li>
						<li>Explicit is better than implicit.</li>
						<li>Simple is better than complex.</li>
						<li>Complex is better than complicated.</li>
						<li>Readability counts.</li>
					</ul>
					<p>Rather than having all of its functionality built into its core, Python was designed to be highly
						extensible. This compact modularity has made it particularly popular as a means of adding programmable
						interfaces to existing applications. Van Rossum's vision of a small core language with a large
						standard
						library and easily extensible interpreter stemmed from his frustrations with ABC, which espoused the
						opposite approach.</p>
					<p>Python strives for a simpler, less-cluttered syntax and grammar while giving developers a choice in
						their coding methodology. In contrast to Perl's "there is more than one way to do it" motto, Python
						embraces a "there should be one—and preferably only one—obvious way to do it" design philosophy. Alex
						Martelli, a Fellow at the Python Software Foundation and Python book author, writes that "To describe
						something as 'clever' is not considered a compliment in the Python culture."</p>

					<p>Python's developers strive to avoid premature optimization, and reject patches to non-critical parts of
						the CPython reference implementation that would offer marginal increases in speed at the cost of
						clarity. When speed is important, a Python programmer can move time-critical functions to extension
						modules written in languages such as C, or use PyPy, a just-in-time compiler. Cython is also
						available,
						which translates a Python script into C and makes direct C-level API calls into the Python
						interpreter.
					</p>

					<p>An important goal of Python's developers is keeping it fun to use. This is reflected in the language's
						name—a tribute to the British comedy group Monty Python—and in occasionally playful approaches to
						tutorials and reference materials, such as examples that refer to spam and eggs (from a famous Monty
						Python sketch) instead of the standard foo and bar.</p>

					<p>A common neologism in the Python community is pythonic, which can have a wide range of meanings related
						to program style. To say that code is pythonic is to say that it uses Python idioms well, that it is
						natural or shows fluency in the language, that it conforms with Python's minimalist philosophy and
						emphasis on readability. In contrast, code that is difficult to understand or reads like a rough
						transcription from another programming language is called unpythonic.</p>

					<p>Users and admirers of Python, especially those considered knowledgeable or experienced, are often
						referred to as Pythonistas</p>
				</section>
				<code class="main-section" id="Syntax_and_Semantics">
					<header>
						<h2>Syntax and Semantics</h2>
					</header>
					<h3><u><em>Keywords</em></u></h3>
					<p>Python has the following keywords or reserved words; they cannot be used as identifiers.</p>
					<ul>
						<li><code>and</code></li>
						<li><code>as</code></li>
						<li><code>assert</code></li>
						<li><code>async</code></li>
						<li><code>await</code></li>
						<li><code>break</code></li>
						<li><code>class</code></li>
						<li><code>continue</code></li>
						<li><code>def</code></li>
						<li><code>del</code></li>
						<li><code>elif</code></li>
						<li><code>else</code></li>
						<li><code>except</code></li>
						<li><code>False</code></li>
						<li><code>finally</code></li>
						<li><code>far</code></li>
						<li><code>from</code></li>
						<li><code>global</code></li>
						<li><code>if</code></li>
						<li><code>import</code></li>
						<li><code>in</code></li>
						<li><code>is</code></li>
						<li><code>lambda</code></li>
						<li><code>None</code></li>
						<li><code>nonLocal</code></li>
						<li><code>not</code></li>
						<li><code>or</code></li>
						<li><code>pass</code></li>
						<li><code>raise</code></li>
						<li><code>return</code></li>
						<li><code>True</code></li>
						<li><code>try</code></li>
						<li><code>while</code></li>
						<li><code>with</code></li>
						<li><code>yeld</code></li>
					</ul>
					<h3><u><em>Indentation</em></u></h3>
					<p>
						Python uses whitespace to delimit control flow blocks (following the off-side rule). Python borrows
						this feature from its predecessor ABC: instead of punctuation or keywords, it uses indentation to
						indicate the run of a block.
						In so-called "free-format" languages — that use the block structure derived from ALGOL — blocks of
						code
						are set off with braces <code>({ })</code> or keywords. In most coding conventions for these
						languages,
						programmers conventionally indent the code within a block, to visually set it apart from the
						surrounding code (prettyprinting).
					</p>
					<p>
						Consider a function, <code>foo</code>, which is passed a single parameter, <code>x</code>, and if the
						parameter is 0 will call <code>bar</code> and <code>baz</code>, otherwise it will call
						<code>qux</code>, passing <code>x</code>, and also call itself recursively, passing <code>x-1</code>
						as
						the parameter. Here are implementations of this function in both C and Python:
						<code>foo</code> function in C with K&R indent style:
					</p>
					<pre><code>
		void foo(int x)
		{
			if (x == 0) {
				bar();
				baz();
			} else {
				qux(x);
				foo(x - 1);
			}
		}
		</code></pre>
					<p><code>foo</code> function in Python:</p>
					<pre><code>
		def foo(x):
			if x == 0:
				bar()
				baz()
			else:
				qux(x)
				foo(x - 1)
		</pre>
				</code>
				<p>Python mandates a convention that programmers in ALGOL-style languages often follow. Incorrectly indented
					code can be understood by human reader differently than does a compiler or interpreter.</p>
				<p>This example illustrates an indentation error in Python: </p>
				<pre><code>
		def foo(x):
			if x == 0:
				bar()
				baz()
			else:
				qux(x)
			foo(x - 1)
		</pre></code>
				<p>Here, in contrast to the above Python foo example, the function call foo(x - 1) always gets executed,
					resulting in an endless recursion. Such an indentation error (like the accidental removal of the
					indentation in the last line) is only possible in programming languages that do not mark blocks with
					distinct markers, like curly brackets in C.
					In this particular case, not even an editor with automatic indentation could prevent the erroneous
					behaviour of this Python code. This unintended error can easily pass into the code base without prior
					noticing by the programmer.
					In most other programming languages, this would not be possible (deleting a block-end marker in C would
					lead to a compiler error), and this makes the Python syntax less robust than most other languages. </p>
				<p>Both space characters and tab characters are currently accepted as forms of indentation in Python. Since
					many tools do not visually distinguish them, mixing spaces and tabs can create bugs that take specific
					efforts to find (a perennial suggestion among Python users has been removing tabs as block markers; other
					Python users propound removing spaces instead).
					Moreover, formatting routines which remove whitespace—for instance, many Internet forums—can destroy the
					syntax of a Python program, whereas a program in a bracketed language would merely become more difficult
					to
					read. </p>
				<p>Many popular code editors handle Python's indentation conventions seamlessly, sometimes after a
					configuration option is enabled. </p>
				<h3><u><em>Data structures</em></u></h3>
				<p>Since Python is a dynamically typed language, Python values, not variables, carry type. This has
					implications for many aspects of the way the language functions.</p>
				<p>All variables in Python hold references to objects, and these references are passed to functions; a
					function
					cannot change the value of variable references in its calling function (but see below for exceptions).
					Some
					people (including Guido van Rossum himself) have called this parameter-passing scheme "Call by object
					reference."
					An object reference means a name, and the passed reference is an "alias", i.e. a copy of the reference to
					the same object, just as in C/C++. The object's value may be changed in the called function with the
					"alias", for example: </p>
				<pre><code>
		>>> alist = ['a', 'b', 'c']
		>>> def my_func(al):
		... al.append('x')
		... print(al)
		...
		>>> my_func(alist)
		['a', 'b', 'c', 'x']
		>>> alist
		['a', 'b', 'c', 'x']
		</code></pre>
				<p>Function <code>my_func</code> changed the value of <code>alist</code> with the formal argument
					<code>al</code>, which is an alias of <code>alist</code>. However, any attempt to operate on the alias
					itself will have no effect on the original object.
					In Python, non-innermost-local and not-declared-global accessible names are all aliases. </p>
				<p>Among dynamically typed languages, Python is moderately type-checked. Implicit conversion is defined for
					numeric types (as well as booleans), so one may validly multiply a complex number by an integer (for
					instance) without explicit casting.
					However, there is no implicit conversion between, for example, numbers and strings; a string is an invalid
					argument to a mathematical function expecting a number.</p>
				<h4>Base types</h4>
				<p>Python has a broad range of basic data types. Alongside conventional integer and floating-point arithmetic,
					it transparently supports arbitrary-precision arithmetic, complex numbers, and decimal floating point
					numbers.
					Python supports a wide variety of string operations. Strings in Python are immutable, so a string
					operation
					such as a substitution of characters, that in other programming languages might alter a string in place,
					returns a new string in Python.
					Performance considerations sometimes push for using special techniques in programs that modify strings
					intensively, such as joining character arrays into strings only as needed. </p>
				<h4>Collection types</h4>
				<p>One of the very useful aspects of Python is the concept of collection (or container) types. In general a
					collection is an object that contains other objects in a way that is easily referenced or indexed.
					Collections come in two basic forms: sequences and mappings. </p>
				<p>The ordered sequential types are lists (dynamic arrays), tuples, and strings. All sequences are indexed
					positionally (0 through length − 1) and all but strings can contain any type of object, including multiple
					types in the same sequence. Both strings and tuples are immutable, making them perfect candidates for
					dictionary keys (see below).
					Lists, on the other hand, are mutable; elements can be inserted, deleted, modified, appended, or sorted
					in-place. </p>
				<p>Mappings, on the other hand, are unordered types implemented in the form of dictionaries which "map" a set
					of immutable keys to corresponding elements (much like a mathematical function). For example, one could
					define a dictionary having a string "toast" mapped to the integer 42 or vice versa.
					The keys in a dictionary must be of an immutable Python type, such as an integer or a string, because
					under
					the hood they are implemented via a hash function. This makes for much faster lookup times, but requires
					keys not change (and also results in a dictionary's lack of order).</p>
				<p>Dictionaries are also central to the internals of the language as they reside at the core of all Python
					objects and classes: the mappings between variable names (strings) and the values which the names
					reference
					are stored as dictionaries (see Object system).
					Since these dictionaries are directly accessible (via an object's <code>__dict__</code> attribute),
					metaprogramming is a straightforward and natural process in Python. </p>
				<p>A set collection type was added to the core language in version 2.4. A set is an unindexed, unordered
					collection that contains no duplicates, and implements set theoretic operations such as union,
					intersection, difference, symmetric difference, and subset testing.
					There are two types of sets: <code>set</code> and <code>frozenset</code>, the only difference being that
					<code>set</code> is mutable and <code>frozenset</code> is immutable.
					Elements in a set must be hashable. Thus, for example, a <code>frozenset</code> can be an element of a
					regular <code>set</code> whereas the opposite is not true. </p>
				<p>Python also provides extensive collection manipulating abilities such as built in containment checking and
					a
					generic iteration protocol. </p>
				<h4>Object system</h4>
				<p>In Python, everything is an object, even classes. Classes, as objects, have a class, which is known as
					their
					metaclass. Python also supports multiple inheritance and mixins.
					The language supports extensive introspection of types and classes. Types can be read and compared—types
					are instances of <code>type</code>. The attributes of an object can be extracted as a dictionary.
					Operators can be overloaded in Python by defining special member functions - for instance, defining
					<code>__add__</code> on a class permits one to use the <code>+</code> operator on members of that class.
				</p>
				<h3><u><em>Literals</em></u></h3>
				<h4>Strings</h4>
				<p>Python has various kinds of string literals. </p>
				<ul>
					<li><strong>Normal string literals</strong></li>
					<p>Either single or double quotes can be used to quote strings. Unlike in Unix shell languages, Perl or
						Perl-influenced languages such as Ruby or Groovy, single quotes and double quotes function
						identically,
						i.e. there is no string interpolation of $foo expressions.
						However, interpolation can be done in various ways: with "f-strings" (since Python 3.6), using the
						format method or the old % string-format operator. </p>
					<p>For instance, the Perl statement:</p>
					<pre><code>print "I just printed $num pages to the printer $printer\n"</code></pre>
					<p>is equivalent to any of these Python statements:</p>
					<pre><code>
			print("I just printed {num} pages to the printer {printer}")
			
			print("I just printed {0} pages to the printer {1}".format(num, printer))
			print("I just printed {num} pages to the printer {printer}".format(num=num, printer=printer))
			
			print("I just printed %s pages to the printer %s" % (num, printer))
			print("I just printed %(num)s pages to the printer %(printer)s" % {"num": num, "printer": printer})
			</code></pre>
					<li><strong>Multi-line string literals</strong></li>
					<p>There are also multi-line strings, which begin and end with a series of three single or double quotes
						and function like here documents in Perl and Ruby.
						A simple example with variable interpolation (using the <code>format</code> method) is: </p>
					<pre><code>print("""Dear {recipient},
			
			I wish you to leave Sunnydale and never return.
			
			Not Quite Love,
			{sender}
			""".format(sender="Buffy the Vampire Slayer", recipient="Spike"))
			</code></pre>
					<li><strong>Raw strings</strong></li>
					<p>Finally, all of the previously mentioned string types come in "raw" varieties (denoted by placing a
						literal r before the opening quote), which do no backslash-interpolation and hence are very useful for
						regular expressions; compare "@-quoting" in C#.
						Raw strings were originally included specifically for regular expressions. Due to limitations of the
						tokenizer, raw strings may not have a trailing backslash.
						Creating a raw string holding a Windows path ending with a backslash requires some variety of
						workaround (commonly, using forward slashes instead of backslashes, since Windows accepts both).
						Examples include:</p>
					<pre><code>
			>>> # A Windows path, even raw strings cannot en in a backslash
			>>> r"C:\Foo\Bar\Baz\"
			  File "<stdin>", line 1
				r"C:\Foo\Bar\Baz\"
				                 ^
			 SyntaxError: EOL while scanning string literal
			 
			>>> dos_path = r"C:\Foo\Bar\Baz\" # avoids the errror by adding
			>>> dos_path.rstrip(()            # and removing trailing space
			'C:\\Foo\\Bar\\Baz\\'
			
			>>> quoted_dos_path = r'"{}"'.format(dos_path)
			>>> quoted_dos_path
			'"C:\\Foo\\Bar\\Baz\\ "'
			
			>>> # A regular expression matching a quoted string with possible backslash quoting
			>>> re.match(r'"(([^"\\]|\\.)*)"', quoted_dos_path).group(1).rstrip()
			'C:\\Foo\\Bar\\Baz\\'
			
			>>> code = 'foo(2, bar)'
			>>> # Reverse the arguments in a two-arg function call
			>>> re.sub(r'\(([^,]*?),([^ ,]*?\)', r'(\2, \1)' , code)
			'foo(2, bar)'
			>>> # Note that this won't work if either argument has parens or commas in it.
			</code></pre>
					<li><strong>Concatenation of adjacent string literals</strong></li>
					<p>String literals (using possibly different quote conventions) appearing contiguously and only separated
						by whitespace (including new lines), are allowed and are aggregated into a single longer string. Thus
					</p>
					<pre><code>
			title = "One Good Turn: " \
			'A Natural History of the Screwdriver and the Screw'
			</code></pre>
					<p>is equivalent to</p>
					<pre><code>title = "One Good Turn: A Natural History of the Screwdriver and the Screw"</code></pre>
					<li><strong>Numbers</strong></li>
					<p>Numeric literals in Python are of the normal sort, e.g. <code>0, -1, 3.4, 3.5e-8</code>. </p>
					<p>Python has arbitrary-length integers and automatically increases the storage size as necessary. Prior
						to
						Python version 3, there were two kinds of integral numbers: traditional fixed size integers and "long"
						integers of arbitrary range. The conversion to "long" integers was performed automatically when
						required,
						and thus the programmer usually didn't have to be aware of the two integral types. In newer language
						versions the fixed-size integers are completely gone. </p>
					<p>Python supports normal floating point numbers, which are created when a dot is used in a literal (e.g.
						<code>1.1</code>), when an integer and a floating point number are used in an expression, or as a
						result of some mathematical operations ("true division" via the / operator, or exponentiation with a
						negative exponent).
						Python also supports complex numbers natively. Complex numbers are indicated with the <code>J</code>
						or
						<code>j</code> suffix, e.g. <code>3 + 4j</code>. </p>
					<li><strong>Lists, Tuples, sets, dictionaries</strong></li>
					<p>Python has syntactic support for the creation of container types.
						<strong>Lists</strong> (class <code>list</code>) are mutable sequences of items of arbitrary types,
						and
						can be created either with the special syntax </p>
					<pre><code>a_list = [1, 2, 3, "a dog"]</code></pre>
					<p>or using normal object recreation</p>
					<pre><code>
			a_second_list = list()
			a_second_list.append(4)
			a_second_list.append(5)
			</code></pre>
					<p><strong>Tuples</strong>(class <code>tuple</code>) are immutable sequences of items of arbitrary types.
						There is also a special syntax to create tuples</p>
					<pre><code>a_tuple = 1, 2, 3, "four"</code></pre>
					<p>Although tuples are created by separating items with commas, the whole construct is usually wrapped in
						parentheses to increase readability. An empty tuple is denoted by <code>()</code>.</p>
					<p><strong>Sets</strong> (class <code>set</code>) are mutable containers of hashable items of arbitrary
						types, with no duplicates. The items are not ordered, but sets support iteration over the items. A
						syntax for set creation appeared in Python 2.7/3.0 </p>
					<pre><code>some_set = {0, (), False}</code></pre>
					<p>In earlier Python versions, sets would be created by initializing the set class with a list argument.
						Python sets are very much like mathematical sets, and support operations like set intersection and
						union.
						Python also features a frozenset class for immutable sets. </p>
					<p><strong>Dictionaries</strong> (class <code>dict</code>) are mutable mappings tying keys and
						corresponding values. Python has special syntax to create dictionaries (<code>{key: value}</code>)</p>
					<pre><code>a_dicitionary = {"key 1": "value 1", 2: 3, 4: []}</code></pre>
					<p>The dictionary syntax is similar to the set syntax, the difference is the presence of colons. The empty
						literal <code>{}</code> results in an empty dictionary rather than an empty set, which is instead
						created using the non-literal constructor: <code>set()</code>. </p>
				</ul>
				<h3><u><em>Operators</em></u></h3>
				<h4>Arithmetic</h4>
				<p>Python includes the <code>+, -, *, /, %</code> (modulus), and <code>**</code> (exponentiation) operators,
					with their usual mathematical precedence.
					Traditionally, <code>x / y</code> performed integer division if both <code>x</code> and <code>y</code>
					were
					integers (returning the floor of the quotient), and returned a float if either was a float.
					However, because Python is a dynamically typed language, it was not always possible to tell which
					operation
					was being performed, which often led to subtle bugs. For example, with </p>
				<pre><code>
		def mean (seq):
			return sum(seq) / len(seq)
		</code></pre>
				<p>A call to <code>mean([3.0, 4.0])</code> would return 3.5, but <code>mean([3, 4])</code> would return 3. If
					this was not the intended behavior, it was necessary to use a workaround such as </p>
				<pre><code>
		def mean (seq):
			return float(sum(seq) / len(seq)
		</code></pre>
				<p>To avoid this issue, a proposal was made to change the behavior of the Python division operator. In Python
					2.2, a
					new operator <code>//</code> was introduced for floor division, both for integer and floating-point
					arguments. The <code>/</code> operator
					was changed so that the quotient of two integers returned a float, but for backwards compatibility, this
					behavior
					had to be explicitly requested until Python 3.0. </p>
				<h4>Comparison Operators</h4>
				<p>The basic comparison operators such as <code>==, <,>=,</code> and so forth are used on all manner of
					values.
					Numbers, strings,sequences, and mappings can all be compared. Although disparate types (such as a
					<code>str</code> and an <code>int</code>) are defined to have a consistent relative ordering, this is
					considered a historical design quirk and will no longer be
					allowed in Python 3.0.</p>
				<p>Chained comparison expressions such as <code>a < b < c</code> have roughly the meaning that they have in
							mathematics, rather than the unusual meaning found in C and similar languages. The terms are
							evaluated and compared in order. The operation has short-circuit semantics, meaning that
							evaluation is guaranteed to stop as soon as a verdict is clear: if <code>a < b</code> is false,
								<code>c</code>
					is never evaluated as the expression cannot possibly be true anymore.</p>
				<p>For expressions without side effects, <code>a < b < c</code> is equivalent to <code>a < b</code> and <code>
								b
								< c</code>. However, there is a substantial difference when the expressions have side effects.
									<code>a < f(x) < b</code> will evaluate <code>f(x)</code>
					exactly once, whereas <code>a < f(x) and f(x) < b</code> will evaluate it twice if the value of a is less
							than <code>f(x)</code>
					and once otherwise.</p>
				<h4>Logical Operators</h4>
				<p>Python 2.2 and earlier does not have an explicit boolean type. In all versions of Python, boolean operators
					treat
					zero values or empty values such as <code>"", 0, None, 0.0, [],</code> and <code>{}</code> as false, while
					in general treating non-empty,
					non-zero values as true. In Python 2.2.1 the boolean constants <code>True</code> and <code>False</code>
					were added to the language
					(subclassed from 1 and 0). The binary comparison operators such as <code>==</code> and <code>></code>
					return either <code>True</code> or <code>False</code>.</p>
				<p>The boolean operators <code>and</code> and <code>or</code> use minimal evaluation. For example, <code>y ==
						0
						or x/y > 100</code> will never raise a
					divide-by-zero exception. These operators return the value of the last operand evaluated, rather than
					<code>True</code> or
					<code>False</code>. Thus the expression <code>(4 and 5)</code> evaluates to <code>5</code>, and <code>(4
						or
						5)</code> evaluates to <code>4</code>.</p>
				<h3><u><em>Functional Programming</em></u></h3>
				<h4>Comprehensions</h4>
				<p>One such construction is the list comprehension, which can be expressed with the following format:</p>
				<pre><code>
      L = [mapping_expression for element in source_list if filter_expression]
      </code></pre>
				<p>Using list comprehension to calculate the first five powers of two:</p>
				<pre><code>
      powers_of_two = [2**n for n in range(1, 6)]
      </code></pre>
				<p>The Quicksort algorithm can be expressed elegantly (albeit inefficiently) using list comprehensions:</p>
				<pre><code>
      def qsort(L):
          if L == []:
              return []
          pivot = L[0]
          return (qsort([x for x in L[1:] if x < pivot]) +
              [pivot] +
              qsort([x for x in L[1:] if x >= pivot]))
      </code></pre>
				<h3><u><em>Objects</em></u></h3>
				<p>
					Python supports most object oriented programming techniques. It allows <b>polymorphism</b>, not only
					within
					a <b>class
						hierarchy</b> but also by <b>duck typing</b>. Any object can be used for any type, and it will work so
					long as it has the proper
					methods and attributes. And everything in Python is an object, including classes, functions, numbers and
					modules.
					Python also has support for <b>metaclasses</b>, an advanced tool for enhancing classes' functionality.
					Naturally,
					<b>inheritance, including <b>multiple inheritance</b>, is supported. It has limited support for private
						variables using <b>name
							mangling</b>. Many Python users don't feel the need for private
						variables, though. The slogan "We're all responsible users here" is used to describe this
						attitude.[16]
						Some consider
						<b>information hiding</b> to be <b>unpythonic</b>, in that it suggests that the class in question
						contains unaesthetic or
						ill-planned internals. However, the strongest argument for name mangling is prevention of
						unpredictable
						breakage of
						programs: introducing a new public variable in a superclass can break subclasses if they don't use
						"private"
						variables.
				</p>
				<p>
					From the tutorial: As is true for modules, classes in Python do not put an absolute barrier between
					definition and
					user, but rather rely on the politeness of the user not to "break into the definition."
				</p>
				<p>
					OOP doctrines such as the use of accessor methods to read data members are not enforced in Python. Just as
					Python
					offers functional-programming constructs but does not attempt to demand <b>referential transparency</b>,
					it
					offers an object
					system but does not demand OOP behavior. Moreover, it is always possible to redefine the class using
					properties so
					that when a certain variable is set or retrieved in calling code, it really invokes a function call, so
					that <code>spam.eggs
						= toast</code> might really invoke <code>spam.set_eggs(toast)</code>. This nullifies the practical
					advantage of accessor functions, and it
					remains OOP because the property eggs becomes a legitimate part of the object's interface: it need not
					reflect an
					implementation detail.
				</p>
				<p>
					In version 2.2 of Python, "new-style" classes were introduced. With new-style classes, objects and types
					were
					unified, allowing the subclassing of types. Even entirely new types can be defined, complete with custom
					behavior for
					infix operators. This allows for many radical things to be done syntactically within Python. A new
					<b>method resolution
						order</b> for <b>multiple inheritance</b> was also adopted with Python 2.3. It is also possible to run
					custom code while
					accessing or setting attributes, though the details of those techniques have evolved between Python
					versions.
				</p>
				<h4>With statements</h4>
				<p>
					The "with" statement handles resources. One function is called when entering scope and another when
					leaving.
					This prevents forgetting to remove the resource and also handles more complicated situations such as
					exceptions.
				</p>
				<h4>Properties</h4>
				<p>
					Properties allow specially defined methods to be invoked on an object instance by using the same syntax as
					used for
					attribute access. An example of a class defining some properties is:
				</p>
				<pre><code>
		  class MyClass:
		      def __init__(self):
		          self._a = None

		      @property
		      def a(self):
		          return self._a

		      @a.setter # makes the property writable
		      def a(self, value):
		          self._a = value
	  </code></pre>
				<h4>Descriptors</h4>
				<p>
					A class that defines one or more of the special methods <code>__get__(self, instance, owner),
						__set__(self,
						instance,
						value), __delete__(self, instance)</code> can be used as a descriptor. Creating an instance of a
					descriptor as a class
					member of a second class makes the instance a property of the second class.
				</p>
				<h4>Class and static methods</h4>
				<p>
					Python allows the creation of class methods and static method via the use of the <code>@classmethod</code>
					and <code>@staticmethod</code>
					<b>decorators</b>. The first argument to a class method is the class object instead of the self-reference
					to the instance. A
					static method has no special first argument. Neither the instance, nor the class object is passed to a
					static method.
				</p>
				<h3><u><em>Exceptions</em></u></h3>
				<p>
					Python supports (and extensively uses) <b>exception handling</b> as a means of testing for error
					conditions
					and other
					"exceptional" events in a program. Indeed, it is even possible to trap the exception caused by a <b>syntax
						error</b>.
				</p>
				<p>
					Python style calls for the use of exceptions whenever an error condition might arise. Rather than testing
					for access
					to a file or resource before actually using it, it is conventional in Python to just go ahead and try to
					use it,
					catching the exception if access is rejected.
				</p>
				<p>
					Exceptions can also be used as a more general means of non-local transfer of control, even when an error
					is
					not at
					issue. For instance, the <b>Mailman</b> mailing list software, written in Python, uses exceptions to jump
					out of deeply
					nested message-handling logic when a decision has been made to reject a message or hold it for moderator
					approval.
				</p>
				<p>
					Exceptions are often used as an alternative to the <code>if</code>-block, especially in <b>threaded</b>
					situations. A commonly invoked
					motto is EAFP, or "It is Easier to Ask for Forgiveness than Permission," which is attributed to <b>Grace
						Hopper</b>. The alternative, known as LBYL, or "Look Before You Leap", explicitly tests for
					pre-conditions.
				</p>
				<p>
					In this first code sample, following the LBYL approach, there is an explicit check for the attribute
					before
					access:
				</p>
				<pre><code>
		  if hasattr(spam, 'eggs'):
		      ham = spam.eggs
		  else:
		      handle_error()
	  </code></pre>
				<p>
					This second sample follows the EAFP paradigm:
				</p>
				<pre><code>
		 try:
		     ham = spam.eggs
		 except AttributeError:
		     handle_error()
	  </code></pre>
				<p>
					These two code samples have the same effect, although there will be performance differences. When
					<code>spam</code> has the
					attribute <code>eggs</code>, the EAFP sample will run faster. When <code>spam</code> does not have the
					attribute <code>eggs</code> (the "exceptional" case),
					the EAFP sample will run slower. The Python <b>profiler</b> can be used in specific cases to determine
					performance
					characteristics. If exceptional cases are rare, then the EAFP version will have superior <b>average
						performance</b> than the
					alternative. In addition, it avoids the whole class of <b>time-of-check-to-time-of-use</b> (TOCTTOU)
					vulnerabilities, other
					<b>race conditions</b>, and is compatible with <b>duck typing</b>. A drawback of EAFP is that it can be
					used only with
					statements; an exception cannot be caught in a generator expression, list comprehension, or lambda
					function.
				</p>
				<h3><u><em>Comments and docstrings</em></u></h3>
				<p>Python has two ways to annotate Python code. One is by using comments to indicate what some part of the
					code
					does.
					Single-line comments begin with the hash character ("#") and are terminated by the end of line. Comments
					spanning
					more than one line are achieved by inserting a multi-line string (with <code>"""</code> as the delimiter
					on
					each
					end) that is
					not used in assignment or otherwise evaluated, but sits in between other statements.</p>
				<p>Commenting a piece of code:</p>
				<pre><code>
		  def getline():
		      return sys.stdin.readline() # Get one line and return it
	  </code></pre>
				<p>Commenting a piece of code with multiple lines:</p>
				<pre><code>
		  def getline():
		      return sys.stdin.readline() """this function
		                                     gets one line
		                                     and returns it"""
	  </code></pre>
				<p><b>Docstrings</b> (documentation strings), that is, strings that are located alone without assignment as
					the
					first
					indented line within a module, class, method or function, automatically set their contents as an attribute
					named
					<code>__doc__</code>, which is intended to store a human-readable description of the object's purpose,
					behavior, and usage.
					The built-in <code>help</code> function generates its output based on <code>__doc__</code> attributes.
					Such
					strings can be delimited with <code>"</code>
					or <code>'</code> for single line strings, or may span multiple lines if delimited with either
					<code>"""</code> or <code>'''</code> which is Python's
					notation for specifying multi-line strings. However, the style guide for the language specifies that
					triple
					double quotes (<code>"""</code>) are preferred for both single and multi-line docstrings.</p>
				<p>Single line docstring:</p>
				<pre><code>
		  def getline():
		      """Get one line from stdin and return it."""
		      return sys.stdin.readline()
	  </code></pre>
				<p>Multi-line docstring:</p>
				<pre><code>
		  def getline():
		      """Get one line
		         from stdin
		         and return it."""
		      return sys.stdin.readline()
	  </code></pre>
				<p>Docstrings can be as large as the programmer wants and contain <b>line breaks</b>. In contrast with
					comments, docstrings
					are themselves Python objects and are part of the interpreted code that Python runs. That means that a
					running
					program can retrieve its own docstrings and manipulate that information. But the normal usage is to give
					other
					programmers information about how to invoke the object being documented in the docstring. </p>
				<p>There are tools available that can extract the docstrings to generate an <b>API</b> documentation from the
					code.
					Docstring documentation can also be accessed from the interpreter with the <code>help()</code> function,
					or
					from the shell
					with the <b>pydoc</b> command <code>pydoc</code>.</p>
				<p>The <b>doctest</b> standard module uses interactions copied from Python shell sessions into docstrings, to
					create tests,
					whereas the <b>docopt</b> module uses them to define command-line options. </p>
				<h3><u><em>Functions annotations</em></u></h3>
				<p>Function annotations are defined in <b>PEP 3107</b>. They allow attaching data to the arguments and return
					of a function.
					The behaviour of annotations is not defined by the language, and is left to third party frameworks. For
					example,
					a library could be written to handle static typing:</p>
				<pre><code>
			  def haul(item: Haulable, *vargs: PackAnimal) -> Distance
		  </code></pre>
				<h3><u><em>Decorators</em></u></h3>
				<p>A decorator is any callable Python object that is used to modify a function, method or class definition. A
					decorator is passed the original object being defined and returns a modified object, which is then bound
					to
					the
					name in the definition. Python decorators were inspired in part by <b>Java annotations</b>, and have a
					similar syntax;
					the decorator syntax is pure syntactic sugar, using <code>@</code> as the keyword</p>
				<pre><code>
			  @viking_chorus
			  def menu_item():
			      print("spam")
		  </code></pre>
				<p>is equivalent to</p>
				<pre><code>
		  def menu_item():
		      print("spam")
		  menu_item = viking_chorus(menu_item)
	  </code></pre>
				<p>Decorators are a form of <b>metaprogramming</b>; they enhance the action of the function or method they
					decorate. For
					example, in the sample below, <code>viking_chorus</code> might cause <code>menu_item</code> to be run 8
					times (see <b>Spam sketch</b>>b) for each
					time it is called:</p>
				<pre><code>
			  def viking_chorus(myfunc):
			      def inner_func(*args, **kwargs):
			          for i in range(8):
			              myfunc(*args, **kwargs)
			      return inner_func
		  </code></pre>
				<p>Canonical uses of function decorators are for creating <b>class methods</b> or <b>static methods</b>,
					adding
					function
					attributes, <b>tracing</b>, setting <b>pre-</b> and <b>postconditions</b>, and <b>synchronization</b>, but
					can be used for far more
					besides, including <b>tail recursion elimination, memoization</b> and even improving the writing of
					decorators.</p>
				<p>Decorators can be chained by placing several on adjacent lines:</p>
				<pre><code>
			  @invincible
			  @favourite_colour("Blue")
			  def black_knight():
			      pass
		  </code></pre>
				<p>is equivalent to</p>
				<pre><code>
			  def black_knight():
			      pass
			  black_knight = invincible(favourite_colour("Blue")(black_knight))
		  </code></pre>
				<p>or, using intermediate variables</p>
				<pre><code>
			  def black_knight():
			      pass
			  blue_decorator = favourite_colour("Blue")
			  decorated_by_blue = blue_decorator(black_knight)
			  black_knight = invincible(decorated_by_blue)
		  </code></pre>
				<p>In the example above, the <code>favourite_color</code> decorator <b>factory</b> takes an argument.
					Decorator
					factories must return a
					decorator, which is then called with the object to be decorated as its argument:</p>
				<pre><code>
				  def favourite_colour(colour):
				      def decorator(func):
				          def wrapper():
				              print(colour)
				              func()
				          return wrapper
				      return decorator
			  </code></pre>
				<p>This would then decorate the <code>black_night</code> function such that the colour, <code>"Blue"</code>,
					would be printed prior to the
					<code>black_knight</code> function running. <b>Closure</b> ensures that the colour argument is accessible
					to the innermost wrapper
					function even when it is returned and goes out of scope, which is what allows decorators to work.</p>
				<p>Despite the name, Python decorators are not an implementation of the <b>decorator pattern</b>. The
					decorator
					pattern is
					a <b>design pattern</b> used in <b>statically typed object-oriented programming languages</b> to allow
					functionality to be
					added to objects at run time; Python decorators add functionality to functions and methods at definition
					time,
					and thus are a higher-level construct than decorator-pattern classes. The decorator pattern itself is
					trivially
					implementable in Python, because the language is <b>duck typed</b>, and so is not usually considered as
					such.</p>
				<h3><u><em>Easter eggs</em></u></h3>
				<p>Users of curly bracket programming languages, such as C or Java, sometimes expect or wish Python to follow
					a
					block-delimiter convention.
					Brace-delimited block syntax has been repeatedly requested, and consistently rejected by core developers.
					The Python interpreter contains an easter egg that summarizes its developers' feelings on this issue.
					The code <code>from __future__ import braces</code> raises the exception <code></code>SyntaxError: not a
					chance</code>. The <code>__future__ module</code> is normally used to provide features from future
					versions
					of Python. </p>
				<p>Another hidden message, The Zen of Python (a summary of Python philosophy), is displayed when trying to
					<code>import this</code>. </p>
				<p>The message <code>Hello world!</code> is printed when the import statement <code>import __hello__</code> is
					used. In Python 2.7, instead of <code>Hello world!</code> it prints <code>Hello world....</code>
					An <code>antigravity</code> module was added to Python 2.7 and 3.0. Importing it opens a web browser to
					xkcd comic 353 that portrays a humorous fictional use for such a module, intended to demonstrate the ease
					with which Python modules enable additional functionality.
					In Python 3.0, this module also contains an implementation of the "geohash" algorithm, a reference to xkcd
					comic 426.</p>
			</section>
			<section class="main-section" id="Libraries">
				<header>
					<h2>Libraries</h2>
				</header>
				<p>Python's large standard library, commonly cited as one of its greatest strengths, provides tools suited to
					many tasks.
					For Internet-facing applications, many standard formats and protocols such as MIME and HTTP are supported.
					It includes modules for creating graphical user interfaces, connecting to relational databases, generating
					pseudorandom numbers, arithmetic with arbitrary-precision decimals,[102] manipulating regular expressions,
					and unit testing.
					Some parts of the standard library are covered by specifications (for example, the Web Server Gateway
					Interface (WSGI) implementation wsgiref follows PEP 333[103]), but most modules are not.
					They are specified by their code, internal documentation, and test suites (if supplied). However, because
					most of the standard library is cross-platform Python code, only a few modules need altering or rewriting
					for variant implementations.
					As of November 2019, the Python Package Index (PyPI), the official repository for third-party Python
					software, contains over 200,000[104] packages with a wide range of functionality, including: </p>
				<ul>
					<li>Graphical User Interfaces</li>
					<li>Web frameworks</li>
					<li>Multimedia</li>
					<li>Databases</li>
					<li>Networking</li>
					<li>Test frameworks</li>
					<li>Automation</li>
					<li>Web scrapping</li>
					<li>Documentation</li>
					<li>System administration</li>
					<li>Scientific computing</li>
					<li>Text processing</li>
					<li>Image processing</li>
					<li>Machine learning</li>
					<li>Data Analytics</li>
				</ul>
			</section>
			<section class="main-section" id="Development">
				<header>
					<h2>Development</h2>
				</header>
				<p>
					Python's development is conducted largely through the Python Enhancement Proposal (PEP) process, the
					primary mechanism for proposing major new features, collecting community input on issues and documenting
					Python design decisions.[123] Python coding style is covered in PEP 8.[124] Outstanding PEPs are reviewed
					and commented on by the Python community and the steering council.
					Enhancement of the language corresponds with development of the CPython reference implementation. The
					mailing list python-dev is the primary forum for the language's development.
					Specific issues are discussed in the Roundup bug tracker hosted at bugs.python.org. Development originally
					took place on a self-hosted source-code repository running Mercurial, until Python moved to GitHub in
					January 2017.
					CPython's public releases come in three types, distinguished by which part of the version number is
					incremented:
					<ul>
						<li>Backward-incompatible versions, where code is expected to break and need to be manually ported.
							The
							first part of the version number is incremented. These releases happen infrequently—for example,
							version 3.0 was released 8 years after 2.0.</li>
						<li>Major or "feature" releases, about every 18 months, are largely compatible but introduce new
							features. The second part of the version number is incremented. Each major version is supported by
							bugfixes for several years after its release.</li>
						<li>Bugfix releases, which introduce no new features, occur about every 3 months and are made when a
							sufficient number of bugs have been fixed upstream since the last release. Security
							vulnerabilities
							are also patched in these releases. The third and final part of the version number is incremented.
						</li>
					</ul>
					<p>
						Python 3.9 alpha1 was announced in November 2019 and with the adoption of a new yearly release
						cadence,
						the first release of 3.9 is slated for November 2020.
						Many alpha, beta, and release-candidates are also released as previews and for testing before final
						releases. Although there is a rough schedule for each release, they are often delayed if the code is
						not ready. Python's development team monitors the state of the code by running the large unit test
						suite during development, and using the BuildBot continuous integration system.
						The community of Python developers has also contributed over 206,000 software modules (as of 29
						November 2019) to the Python Package Index (PyPI), the official repository of third-party Python
						libraries.
						The major academic conference on Python is PyCon. There are also special Python mentoring programmes,
						such as Pyladies.

			</section>
			<section class="main-section" id="Implementations">
				<header>
					<h2>Implementations</h2>
				</header>
				<h3>Reference Implementation</h3>
				<p>CPython is the reference implementation of Python. It is written in C, meeting the C89 standard with
					several
					select C99 features.[107] It compiles Python programs into an intermediate bytecode[108] which is then
					executed by its virtual machine.[109]
					CPython is distributed with a large standard library written in a mixture of C and native Python. It is
					available for many platforms, including Windows and most modern Unix-like systems. Platform portability
					was
					one of its earliest priorities.</p>
			</section>
			<section class="main-section" id="Uses">
				<header>
					<h2>Uses</h2>
				</header>
				<p>Since 2003, Python has consistently ranked in the top ten most popular programming languages in the TIOBE
					Programming Community Index where, as of February 2020, it is the third most popular language (behind
					Java,
					and C).It was selected Programming Language of the Year in 2007, 2010, and 2018.
					An empirical study found that scripting languages, such as Python, are more productive than conventional
					languages, such as C and Java, for programming problems involving string manipulation and search in a
					dictionary, and determined that memory consumption was often "better than Java and not much worse than C
					or
					C++".</p>
				<p>Large organizations that use Python include Wikipedia, Google, Yahoo!, CERN, NASA, Facebook, Amazon,
					Instagram, Spotify and some smaller entities like ILM and ITA. The social news networking site Reddit is
					written entirely in Python.
					Python can serve as a scripting language for web applications, e.g., via mod_wsgi for the Apache web
					server. With Web Server Gateway Interface, a standard API has evolved to facilitate these applications.
					Web frameworks like Django, Pylons, Pyramid, TurboGears, web2py, Tornado, Flask, Bottle and Zope support
					developers in the design and maintenance of complex applications. Pyjs and IronPython can be used to
					develop the client-side of Ajax-based applications. SQLAlchemy can be used as data mapper to a relational
					database.
					Twisted is a framework to program communications between computers, and is used (for example) by Dropbox.
				</p>
				<p>Libraries such as NumPy, SciPy and Matplotlib allow the effective use of Python in scientific computing,
					with specialized libraries such as Biopython and Astropy providing domain-specific functionality.
					SageMath is a mathematical software with a notebook interface programmable in Python: its library covers
					many aspects of mathematics, including algebra, combinatorics, numerical mathematics, number theory, and
					calculus.</p>
				<p>Python has been successfully embedded in many software products as a scripting language, including in
					finite
					element method software such as Abaqus, 3D parametric modeler like FreeCAD, 3D animation packages such as
					3ds Max, Blender, Cinema 4D, Lightwave, Houdini, Maya, modo, MotionBuilder, Softimage, the visual effects
					compositor Nuke, 2D imaging programs like GIMP, Inkscape, Scribus and Paint Shop Pro, and musical notation
					programs like scorewriter and capella.</p>
				<p>GNU Debugger uses Python as a pretty printer to show complex structures such as C++ containers.
					Esri promotes Python as the best choice for writing scripts in ArcGIS.It has also been used in several
					video games, and has been adopted as first of the three available programming languages in Google App
					Engine, the other two being Java and Go.</p>
				<p>Python is commonly used in artificial intelligence projects with the help of libraries like TensorFlow,
					Keras and Scikit-learn. As a scripting language with modular architecture, simple syntax and rich text
					processing tools, Python is often used for natural language processing.
					Many operating systems include Python as a standard component. It ships with most Linux distributions,
					AmigaOS 4, FreeBSD (as a package), NetBSD, OpenBSD (as a package) and macOS and can be used from the
					command line (terminal). Many Linux distributions use installers written in Python: Ubuntu uses the
					Ubiquity installer, while Red Hat Linux and Fedora use the Anaconda installer. Gentoo Linux uses Python in
					its package management system, Portage.
					Python is used extensively in the information security industry, including in exploit development.</p>
				<p>Most of the Sugar software for the One Laptop per Child XO, now developed at Sugar Labs, is written in
					Python. The Raspberry Pi single-board computer project has adopted Python as its main user-programming
					language.</p>
				<p>LibreOffice includes Python, and intends to replace Java with Python. Its Python Scripting Provider is a
					core feature since Version 4.0 from 7 February 2013.</p>

			</section>
			<section class="main-section" id="Influence">
				<header>
					<h2>Influence</h2>
				</header>
				<p>Python's design and philosophy have influenced many other programming languages:</p>
				<ul>
					<li>Boo uses indentation, a similar syntax, and a similar object model.</li>
					<li>Cobra uses indentation and a similar syntax, and its "Acknowledgements" document lists Python first
						among languages that influenced it. However, Cobra directly supports design-by-contract, unit tests,
						and optional static typing.</li>
					<li>CoffeeScript, a programming language that cross-compiles to JavaScript, has Python-inspired syntax.
					</li>
					<li>ECMAScript borrowed iterators and generators from Python.</li>
					<li>Go is designed for the "speed of working in a dynamic language like Python" and shares the same syntax
						for slicing arrays.</li>
					<li>Groovy was motivated by the desire to bring the Python design philosophy to Java.</li>
					<li>Julia was designed "with true macros [.. and to be] as usable for general programming as Python [and]
						should be as fast as C". Calling to or from Julia is possible; to with PyCall.jl and a Python package
						pyjulia allows calling, in the other direction, from Python.</li>
					<li>Kotlin is a functional programming language with an interactive shell similar to Python. However,
						Kotlin is strongly typed with access to standard Java libraries.</li>
					<li>Ruby's creator, Yukihiro Matsumoto, has said: "I wanted a scripting language that was more powerful
						than Perl, and more object-oriented than Python. That's why I decided to design my own language."</li>
					<li>Swift, a programming language developed by Apple, has some Python-inspired syntax.</li>
					<li>GDScript, dynamically typed programming language used to create video-games. It is extremely similar
						to
						Python with a few minor differences.</li>
				</ul>
				<p>Python's development practices have also been emulated by other languages. For example, the practice of
					requiring a document describing the rationale for, and issues surrounding, a change to the language (in
					Python, a PEP) is also used in Tcl and Erlang.</p>

				<p>Python received TIOBE's Programming Language of the Year awards in 2007, 2010 and 2018. The award is given
					to the language with the greatest growth in popularity over the year, as measured by the TIOBE index.</p>
			</section>
		</main>
	</div>
</div>

<!-- partial -->
  
</body>
</html>
<!-- partial -->
  <script src='https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js'></script><script  src="./script.js"></script>

</body>
</html>
